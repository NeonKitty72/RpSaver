<!--*************************************************************
	Suzanne Kersten
	11/19/017
	RP-Saver: Saves all your rp's in an easy-to-read format!
	
	TODO: 
	* Check that rightName isn't null for Telegram
	* Way to organize RP's, and retrive them all easily from within the app.
		IE, be able to have a 'folder' for 'Kim Stuff' and have a listing 
		of all the rp's in that section.
	* Add in discord tracking
	* Actual good formatting? It works 4 now tho
	
	
	Idea: Make structure of first specieal character, make a 
		struct that tells where it is and what fun to do?
		Then push that and use the beginning of special char
		to put it all into the Done Output
*************************************************************-->
<!DOCTYPE html>
<html lang="en">

<head>
	<title>RP Saver</title>
	<meta charset="UTF-8">
	<link rel="stylesheet" type="text/css" href="stylesheet.css">
	
	<!--***********************************************************************************************************************************
		JAVASCRIPT CODE
	************************************************************************************************************************************-->
	<script>
		var css;				//used in saving the file: contains css for formatting rp output
		const isDebug = true;	//if true, has debug messages. Otherwise does not.
	
		//----Automatic RP Generation-----------------------------------------------------------------------------------------
		function makeItNoice(){			
			var allText = document.getElementById("rp").value;		//Text that is in the user input textArea
			document.getElementById("shitToWrite").innerHTML = "";	//reset current generated rp
			
			//get what chat client the user chose
			var messenger = document.getElementsByName("messenger");
			if (messenger[0].checked){			//user chose telegram
				telegramDecipher(allText);
			} else if (messenger[1].checked) { 	//user chose other
				otherDecipher(allText);
			}
			
			activateSaveButton();		//make the save button available
		}
		
		//****************** Telegram Messaging ******************
		//Parses through the text given, looking for telegram-specific 
		//	ways of formatting.
		function telegramDecipher(allText){
			//parse the two names used
			var names = parseTelegramNames(allText);
			var leftName = names[0], rightName = names[1];		//the names of the two rpers
			if (isDebug) console.log("Left Name: " + leftName + " |Right Name: " + rightName);
			var toOutput = "";									//the text to output
			var left = 1;										//whether to align text left or right
			
			for (var i = 0; i < allText.length; i++){
				//make sure it's not the header line
				if (allText.charAt(i) == leftName.charAt(0)
						&& allText.charAt(i + leftName.length + 2) == "["		//check if there's a [ after their name, plus space for , and the space
						&& allText.charAt(i + leftName.length + 17) == "]"){	// and the ending ]
					left = true;
					i = i + leftName.length + 19;								//note: 19 is total 'header' text after user's name
				} else if (allText.charAt(i) == rightName.charAt(0)
						&& allText.charAt(i + rightName.length + 2) == "["		//same as before, but with right name
						&& allText.charAt(i + rightName.length + 17) == "]"){
					left = false;
					i = i + rightName.length + 19;
				}
				
				//output text, reset vars for next output
				if (allText.charAt(i) == "\n" && allText.charAt(i - 1) != "\n"){					
					toOutput = (left ? leftName : rightName)+ ": " + toOutput;	//add in the users name
					createParagraphElement(toOutput, left);						//add the paragraph element
					
					toOutput = "";	//reset toOutput
				}
				
				//pick up text until we hit crlf
				if (allText.charAt(i) != "\r" && allText.charAt(i) != "\n"){
					toOutput += allText.charAt(i)
				}
			} //end of for loop
			
			if (toOutput != ""){
				toOutput = (left ? leftName : rightName)+ ": " + toOutput;	//needed to grab the last line of text
				createParagraphElement(toOutput, left);						//add the paragraph element
			}
		} //end of telegramDecipher
		
		
		//**************************
		//Guesses the left and right person from the text given: Basically looks for the first two messages and guesses from there
		//returns left and right name as a 2-slot array: left, then right.
		function parseTelegramNames(allText){
			var leftName = "";
			var rightName = "";
			
			//guess left name, then see if we're right.
			var i = 0;
			for (; i < allText.length - 1; i++){
					leftName = allText.substring(0, allText.indexOf(","));
					if (allText.charAt(i + leftName.length + 2) == "["		//check if there's a [ after their name, plus space for , and the space
					  && allText.charAt(i + leftName.length + 17) == "]") {
					  i = i + 19; //skip past this name
						break;
					}
			} 				
				
			//guess right name, then see if it's good
			// We continue from where the last for loop left off to
			// be more efficient.
			for (; i < allText.length - 1; i++){
				rightName = (allText.substring(i, allText.indexOf(",", i)));
				if (rightName == leftName){
					i = i + 19;
				}
				if (rightName != leftName
				  && rightName.indexOf("\n") == -1
				  && allText.charAt(i + rightName.length == ",")
				  && allText.charAt(i + rightName.length + 2) == "["		//same as before, but with right name
				  && allText.charAt(i + rightName.length + 17) == "]"){
					break;	//make sure we didn't just grab the same name
				}
			}
			return [leftName, rightName];
		}
		
		//****************** Other ******************
		//basically just do basic formatting based on newlines and nothing else. 
		// most basic format.
		function otherDecipher(allText){
			var left = true;
			var toOutput = "";
			for (var i = 0; i < allText.length; i++){					
				//output text, reset vars for next output
				if (allText.charAt(i) == "\n"){
					createParagraphElement(toOutput, left); //set up text to display
					toOutput = "";
					left =  !left;
				}
				
				//pick up text until we hit crlf
				if (allText.charAt(i) != "\r" && allText.charAt(i) != "\n")
					toOutput += allText.charAt(i)
			}
			//one last output to grab the last response
			createParagraphElement(toOutput, left);
		}
		
		//****************** helper methods for parsing input ******************
		//takes in the text to put in the paragraph element and whether the paragraph is on left or right
		//returns the created paragraph element.
		function createParagraphElement(text, isLeft){
			var paragraphElement = document.createElement("p");
			paragraphElement.setAttribute("class", isLeft ? "leftRP" : "rightRP");
			paragraphElement.setAttribute("style", "height:auto;");
			paragraphElement.setAttribute("ondblclick", "editElem(this);");
			
			var t = document.createTextNode(text);
			paragraphElement.appendChild(t);
			document.getElementById("shitToWrite").appendChild(paragraphElement);
		}
		
		//-----Saving the RP------------------------------------------------------------------------------------
		/*
			Make Whatever is stored in shitToWrite available to be saved. Get the css from the 
			webpage stored in NeonKitty's GitHub.io page. If that file can't be accessed in 3 seconds, 
			use a baked in version of the css.
		*/
		function activateSaveButton(){
			var headText
			getFileFromServer("https://sskersten.github.io/stylesheet.css", function(text){if (text != null) finishActivateSaveButton(text); });
			setTimeout(function() {checkForValidCSSFileOpen()}, 3000);
		}
		
		/*
			If the css file wasn't grabbed from the server, use the baked in css and still activate the save button.
		*/
		function checkForValidCSSFileOpen(){
			if (document.getElementById("saveBtn").innerHTML == "")
			{
				alert("Could not access most recent CSS file. Using the baked-in CSS. (You can most likely ignore this and continue on with no problems.)");
				var headText = '#shitToWrite{width: 800px;margin: auto;}.leftRP {max-width: 75%;min-width: 40%;background-color: #E9E8F1;font-size: 14px;font-color: #25201C;padding: 10px;margin: 0px;margin-bottom: 4px;border-radius: 10px;float: left;}.rightRP {max-width: 75%;min-width: 40%;background-color: #DCF2D4;font-size: 14px;font-color: #25201C;font-family: Verdana, sans-serif;padding: 10px;margin: 0px;margin-bottom: 4px;border-radius: 10px;float: right;}'		
				finishActivateSaveButton(headText);
			}
		}
		
		/*
			Set up the html of the file to save and prepare the save button, actually activating it.
		*/
		function finishActivateSaveButton(headText){
			
			//Set up the basic html of the file to save
			headText = '<html lang="en"><head><title>RP Saver</title><meta charset="UTF-8"><style>' + headText;
			headText = headText + '</style></head><body><div id="shitToWrite">';
			var text = document.getElementById("shitToWrite").innerHTML;
			//set up the save button to actually save the file 
			var saveBtn = document.getElementById("saveBtn");
			saveBtn.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(headText + text + "</div></body></html>"));
			saveBtn.setAttribute('download', "RP.html");
			saveBtn.innerHTML = "Save this as a web page file";
		
		}
		
		/*
			Gets a file from a server using a basic GET protocol from the specified url. 
			Returns the file contents through a passed in function.
		*/
		function getFileFromServer(url, doneCallBack) {
			var xhr;
			
			xhr = new XMLHttpRequest();
			xhr.onreadystatechange = handleStateChange;
			xhr.open("GET", url, true);
			xhr.send();
			
			function handleStateChange() {
				if (xhr.readyState == 4) {
					doneCallBack(xhr.status == 200 ? xhr.responseText : null);
				}
			}
		}
		
	//----Splitting Elements-------------------------------------------------------------------------------------
	var oldText; 		//the text that was in an rp chat bubble before the user started editing it
	var editingText = false;
	
	//start editing an element: Set the text as editable and create a button to save changes and a button 
	// to delete changes.
	function editElem(element){
		//make sure we're not already editing the element
		if (editingText) {
			alert("you're already editing text!");
			return;
		}
		
		//set up the element to be editable and look editable
		editingText = true;
		oldText = element.innerText;
		element.setAttribute("id", "editingRpPost");		//make it stand out
		element.setAttribute("contenteditable", "true");	//make the content editable
		element.setAttribute("draggable", "false"); 		//make sure they don't accidentally drag the thing
		
		//create a panel with buttons to deal with editing text.
		var editControls = setupEditControls();
		
		element.insertAdjacentElement("afterend", editControls);
		
	}
	
	//make the html elements that control editing
	function setupEditControls(){
		var editControls = document.createElement("div");
		editControls.setAttribute("class", "editControl");
		
		//create the button to save the changes to the text
		var savebtn = document.createElement("button");
		savebtn.appendChild(document.createTextNode("Save Changes"));
		savebtn.setAttribute("type","button");
		savebtn.setAttribute("onmousedown", "finishEdit(this.parentNode.previousElementSibling);");
		editControls.appendChild(savebtn);
		
		//create the button to remove the changes to the text
		var cancelbtn = document.createElement("button");
		cancelbtn.appendChild(document.createTextNode("Cancel Changes"));
		cancelbtn.setAttribute("type","button");
		cancelbtn.setAttribute("onmousedown", "cancelEdit(this.parentNode.previousElementSibling);");
		editControls.appendChild(cancelbtn);
		
		//create a checkbox for whether to reverse what side all future posts are on after this on/
		// if splitting the post into two posts.
		editControls.innerHTML += "<br />";
		var reverseCheckBox = document.createElement("input");
		reverseCheckBox.setAttribute("id", "reverseCheckBox");
		reverseCheckBox.setAttribute("type", "checkbox");
		reverseCheckBox.checked = true;
		var reverseText = document.createElement("span")
		reverseText.appendChild(reverseCheckBox);
		reverseText.appendChild(document.createTextNode("Reverse future rp posts on split."));
		editControls.appendChild(reverseText);
		
		return editControls;
	}
	
	//save the changes that were made to the post, and then check for splits and clean up tags.
	function finishEdit(element){
		checkForSplit(element);
		element.innerHTML = element.innerText;
		cleanUpFromEditing(element);
	}
	
	//cancel the editing. Just reset text, and clean up the tags for moving.
	function cancelEdit(element){
		element.innerHTML = oldText;
		cleanUpFromEditing(element);
	}
	
	//reset the inner tags so that the passed in rp post can be used like normal
	function cleanUpFromEditing(element){
		element.setAttribute("contenteditable", "false");	//make the content uneditable again
		element.setAttribute("draggable", "true"); 			//let them drag it again
		if (element.nextElementSibling.getAttribute("class") == "editControl") 
			element.parentNode.removeChild(element.nextElementSibling);
		if (element.getAttribute("id") == "editingRpPost")
			element.removeAttribute("id");
		editingText=false;
	}
	
	//check for the string {split} in any casing. If it finds it, then add an rp post bubble above
	// with all the text UP TO the split, and make the current bubble have all the text AFTER the split.
	function checkForSplit(elemToSplit){
		var splitPos = elemToSplit.innerHTML.search(/{split}/i);
		
		//if the string was found to be added to the post, then split the post there.
		if (splitPos != -1){
			//save the value of the checkBox before it's deleted
			var reverseCheckBoxValue = document.getElementById("reverseCheckBox").checked;
			
			//Make new elem's text out of the text before split and insert it.
			var newElem = elemToSplit.cloneNode(true);
			newElem.innerHTML = elemToSplit.innerText.substring(0, splitPos);
			elemToSplit.insertAdjacentElement("beforebegin", newElem);
			cleanUpFromEditing(newElem);
			
			//change the text of the html element to everything from after split to the end of the text.
			elemToSplit.innerText = elemToSplit.innerText.substring(splitPos + 7, elemToSplit.innerText.length);
			
			//change the ordering of all the future posts so it makes more sense.
			if (reverseCheckBoxValue == true) reverseAllFuturePosts(elemToSplit);
		}
	}
	
	//recursive function to go through and swap the classes of all the future elements.
	function reverseAllFuturePosts(element){
		if (element == null) return;
			
		if (element.getAttribute("class") == "leftRP")
			element.setAttribute("class","rightRP");
		else if (element.getAttribute("class") == "rightRP")
			element.setAttribute("class","leftRP");
			
		reverseAllFuturePosts(element.nextElementSibling);
	}
	
	//-----------------------------------------------------------------------------------------
	</script>	
</head>

	<!--***********************************************************************************************************************************
		HTML CODE
	************************************************************************************************************************************-->
<body>
	<div id="userInputRp">
		<!-- Where user inputs text -->
		<textarea rows="10" cols="40" name="rp" id="rp"></textarea> 
	
		<!-- Input buttons. Save button is nothing to start because we can't save what user didn't 'compile' -->
		<br />
		<input type="submit" value="Make this look nice!" onclick="makeItNoice()" style="margin-bottom: 10px">
		<a id="saveBtn"></a>
	</div>
	
	<!-- radio buttons for what messenger the user was using -->
	<form action="" style="float:right;">
		<input type="radio" name="messenger" value="telegram" checked="checked"> Telegram<br>
		<input type="radio" name="messenger" value="other"> Other
	</form>
	
	<div id="shitToWrite">
		<!-- Where the rp text will go -->
	</div>
</body>
</html>
